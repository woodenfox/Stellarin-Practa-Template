# Community Practa Asset Resolution

This document outlines how assets are handled across the three phases of community Practa development and publishing.

## Overview

Practa components use a unified pattern for loading assets:

```tsx
import { assets } from "./assets";

<Image source={assets.getImageSource("zen-circle") || undefined} />
```

The `assets.ts` file is **different in each phase**, but the component code stays the same. This eliminates the need for any conditional logic or runtime branching.

---

## Phase 1: Template (Local Development)

### Developer Experience

Developers create Practa using the template. They place images in an `./assets/` folder and register them in `assets.ts`.

### Template `assets.ts` Implementation

```typescript
// assets.ts - LOCAL DEVELOPMENT VERSION
// Developers add entries here as they add images to ./assets/

const localAssets: Record<string, any> = {
  "zen-circle": require("./assets/zen-circle.png"),
  "background": require("./assets/background.jpg"),
  // Add more assets as needed
};

export const assets = {
  getImageSource: (key: string) => localAssets[key] || null,
  getUri: (key: string) => null, // Not available in local dev
};
```

### Developer Instructions

1. Place image files in the `./assets/` folder
2. Add an entry to `localAssets` in `assets.ts` with a kebab-case key
3. Use `assets.getImageSource("key")` in your component
4. Never use `require()` directly in component code

---

## Phase 2: Practa Manager (Publishing)

### What Happens During Publish

When a developer submits their Practa to the Practa Manager:

1. **Upload Assets**: All files from `./assets/` are uploaded to CDN object storage
2. **Generate `build.json`**: Contains metadata and full CDN URLs for each asset
3. **Generate CDN `assets.ts`**: Replaces the local version with a CDN-based resolver
4. **Remove Local Assets**: The `./assets/` folder is not committed to the repo
5. **Commit**: Only the code files, `build.json`, and CDN `assets.ts` are committed

### `build.json` Format

```json
{
  "buildId": "abc123",
  "createdAt": "2025-01-15T10:30:00Z",
  "assets": {
    "zen-circle": "https://replit-objstore.example.com/public/practa/hello-world/abc123/zen-circle.png",
    "background": "https://replit-objstore.example.com/public/practa/hello-world/abc123/background.jpg"
  }
}
```

**Important**: The `assets` map contains **full CDN URLs**, not relative paths. The Stellarin app does not construct URLs - it uses them directly from this map.

### Generated CDN `assets.ts`

The Practa Manager generates this file to replace the local version:

```typescript
// assets.ts - CDN VERSION (auto-generated by Practa Manager)
// DO NOT EDIT - This file is regenerated on each publish

import { createAssetResolver } from "@/lib/practa-assets";

const assetUrls: Record<string, string> = {
  "zen-circle": "https://replit-objstore.example.com/public/practa/hello-world/abc123/zen-circle.png",
  "background": "https://replit-objstore.example.com/public/practa/hello-world/abc123/background.jpg",
};

export const assets = createAssetResolver(assetUrls);
```

### Practa Manager Implementation Notes

The publish pipeline should:

1. Parse the local `assets.ts` to extract asset keys (or scan `./assets/` folder)
2. Upload each asset to CDN: `public/practa/{slug}/{buildId}/{filename}`
3. Generate `build.json` with full URLs in the `assets` map
4. Generate the CDN `assets.ts` using the template above
5. Validate that no `require()` statements remain in component code
6. Commit only: `index.tsx`, `assets.ts`, `build.json`, `practa.json`

---

## Phase 3: Stellarin App (Import)

### What Happens at Build Time

The Stellarin fetch script (`scripts/fetch-community-practa.js`):

1. Clones/pulls the `stellarin-practa` GitHub repo
2. For each Practa, reads `build.json`
3. Generates `assets.ts` from the URLs in `build.json`
4. Validates that no `require()` statements exist in component code (fails build if found)

### Generated `assets.ts`

```typescript
// assets.ts - Generated by fetch-community-practa.js
// DO NOT EDIT MANUALLY

import { createAssetResolver } from "@/lib/practa-assets";

const assetUrls: Record<string, string> = {
  "zen-circle": "https://replit-objstore.example.com/public/practa/hello-world/abc123/zen-circle.png",
};

export const assets = createAssetResolver(assetUrls);
```

### Asset Resolver Implementation

```typescript
// client/lib/practa-assets.ts

export interface AssetResolver {
  getImageSource: (key: string) => { uri: string } | null;
  getUri: (key: string) => string | null;
}

export function createAssetResolver(urls: Record<string, string>): AssetResolver {
  return {
    getImageSource: (key: string) => {
      const url = urls[key];
      return url ? { uri: url } : null;
    },
    getUri: (key: string) => urls[key] || null,
  };
}
```

---

## Summary of Changes Needed

| App | Required Changes |
|-----|------------------|
| **Template** | Ship with local `assets.ts` that uses `require()`. Document the `assets.getImageSource()` pattern. |
| **Practa Manager** | Generate CDN `assets.ts` during publish. Store full URLs in `build.json`. Strip `./assets/` folder before commit. Validate no `require()` in component code. |
| **Stellarin** | Fetch script already generates `assets.ts` from `build.json`. Add validation to fail if `require()` is detected. |

---

## Key Design Decisions

1. **Full URLs in `build.json`**: The Stellarin app does not construct CDN URLs. The `assets` map contains complete URLs, making the system simpler and more flexible (CDN can change without app updates).

2. **No `buildId` in URL construction**: Since URLs are stored in full, the `buildId` is only metadata. The app just reads URLs directly from the map.

3. **`assets.ts` is the boundary**: This single file is the only thing that changes between phases. Component code is identical everywhere.

4. **Validation at boundaries**: Both the Practa Manager (on publish) and Stellarin (on fetch) validate that no `require()` statements exist in component code.
