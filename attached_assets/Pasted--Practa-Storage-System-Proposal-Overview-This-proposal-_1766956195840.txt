# Practa Storage System Proposal

## Overview

This proposal outlines a persistence system that allows community practa to save and restore state across sessions. This enables use cases like remembering user preferences (difficulty level, timer duration) or saving progress in multi-session activities.

## Goals

1. **Simple API** - Practa authors use intuitive get/set methods
2. **Automatic isolation** - Each practa's data is namespaced by slug AND user
3. **Local-first** - Works offline using AsyncStorage
4. **Safe** - Untrusted community code can't access other practa's data or pollute global storage
5. **Resilient** - Graceful error handling for corrupted data or storage failures

## API Design

### PractaStorage Interface

```typescript
interface PractaStorage {
  get<T = unknown>(key: string): Promise<T | null>;
  set<T = unknown>(key: string, value: T): Promise<void>;
  remove(key: string): Promise<void>;
  clear(): Promise<void>;
}
```

### Error Handling

All methods return promises that may reject. Community practa should handle errors gracefully:

```typescript
try {
  const difficulty = await context.storage.get<string>("difficulty");
} catch (error) {
  // Storage unavailable or corrupted - use default
  console.warn("Storage error, using defaults");
}
```

### Usage in a Community Practa

```typescript
function DailySudoku({ context, onComplete }: PractaComponentProps) {
  const [difficulty, setDifficulty] = useState<string>("medium");
  
  // Load saved preference on mount
  useEffect(() => {
    context.storage.get<string>("difficulty")
      .then((saved) => {
        if (saved) setDifficulty(saved);
      })
      .catch(() => {
        // Ignore errors, use default
      });
  }, []);
  
  // Save when user changes difficulty
  const handleDifficultyChange = async (level: string) => {
    setDifficulty(level);
    try {
      await context.storage.set("difficulty", level);
    } catch (error) {
      // Storage full or unavailable - continue without saving
    }
  };
  
  // ... rest of component
}
```

## Namespacing Strategy

### User-Aware Isolation

All storage keys include BOTH the user identifier AND practa slug:

```
practa:{userId}:{slug}:{key}
```

| User | Practa Slug | User Key | Actual AsyncStorage Key |
|------|-------------|----------|-------------------------|
| user-123 | daily-sudoku | difficulty | `practa:user-123:daily-sudoku:difficulty` |
| user-456 | daily-sudoku | difficulty | `practa:user-456:daily-sudoku:difficulty` |
| user-123 | one-word-a-day | streak | `practa:user-123:one-word-a-day:streak` |

**Privacy benefit**: Users on a shared device don't see each other's data.

### Anonymous Users

For users not signed in, use the device's anonymous ID (already tracked in the app):
```
practa:anon-{deviceId}:daily-sudoku:difficulty
```

### Canonical Slug Resolution

- **Community practa**: Use `metadata.json` slug field (e.g., `daily-sudoku`)
- **Built-in practa**: Use a dedicated registry mapping (e.g., `journal` → `builtin-journal`)

This avoids collisions between community and built-in practa types.

## Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Practa Component                      │
│                                                          │
│   context.storage.get("difficulty")                      │
│   context.storage.set("difficulty", "hard")              │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                     PractaContext                        │
│                                                          │
│   storage: PractaStorage  ←  injected by FlowScreen      │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                  PractaStorageManager                    │
│                                                          │
│   - Receives userId + slug on construction               │
│   - Prefixes keys: "practa:{userId}:{slug}:{key}"        │
│   - Validates values (size, serializability)             │
│   - Tracks and enforces per-practa quota                 │
│   - Safe JSON parsing with fallback                      │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                     AsyncStorage                         │
│                                                          │
│   Persists to device - survives app restarts             │
└─────────────────────────────────────────────────────────┘
```

## Implementation Details

### PractaStorageManager Class

Located at `client/lib/practa-storage.ts`:

```typescript
import AsyncStorage from "@react-native-async-storage/async-storage";

const STORAGE_PREFIX = "practa";
const MAX_VALUE_SIZE = 10 * 1024; // 10KB per value
const MAX_TOTAL_SIZE = 100 * 1024; // 100KB total per practa per user
const QUOTA_KEY_SUFFIX = "__quota__";

export interface PractaStorage {
  get<T = unknown>(key: string): Promise<T | null>;
  set<T = unknown>(key: string, value: T): Promise<void>;
  remove(key: string): Promise<void>;
  clear(): Promise<void>;
}

export class PractaStorageManager implements PractaStorage {
  private prefix: string;
  private quotaKey: string;
  
  constructor(userId: string, slug: string) {
    this.prefix = `${STORAGE_PREFIX}:${userId}:${slug}:`;
    this.quotaKey = `${this.prefix}${QUOTA_KEY_SUFFIX}`;
  }
  
  private getFullKey(key: string): string {
    return `${this.prefix}${key}`;
  }
  
  private async getUsedBytes(): Promise<number> {
    try {
      const quota = await AsyncStorage.getItem(this.quotaKey);
      return quota ? parseInt(quota, 10) : 0;
    } catch {
      return 0;
    }
  }
  
  private async updateUsedBytes(delta: number): Promise<void> {
    const current = await this.getUsedBytes();
    const newTotal = Math.max(0, current + delta);
    await AsyncStorage.setItem(this.quotaKey, String(newTotal));
  }
  
  async get<T = unknown>(key: string): Promise<T | null> {
    try {
      const value = await AsyncStorage.getItem(this.getFullKey(key));
      if (value === null) return null;
      return JSON.parse(value) as T;
    } catch (error) {
      // Corrupted data - return null rather than crash
      console.warn(`PractaStorage: Failed to parse key "${key}"`, error);
      return null;
    }
  }
  
  async set<T = unknown>(key: string, value: T): Promise<void> {
    // Serialize and validate
    let serialized: string;
    try {
      serialized = JSON.stringify(value);
    } catch (error) {
      throw new Error("Value is not serializable");
    }
    
    const valueSize = serialized.length;
    
    // Check per-value limit
    if (valueSize > MAX_VALUE_SIZE) {
      throw new Error(`Value exceeds maximum size of ${MAX_VALUE_SIZE} bytes`);
    }
    
    // Check total quota
    const fullKey = this.getFullKey(key);
    const existingValue = await AsyncStorage.getItem(fullKey);
    const existingSize = existingValue ? existingValue.length : 0;
    const usedBytes = await this.getUsedBytes();
    const newTotal = usedBytes - existingSize + valueSize;
    
    if (newTotal > MAX_TOTAL_SIZE) {
      throw new Error(`Storage quota exceeded (${MAX_TOTAL_SIZE} bytes)`);
    }
    
    // Write value and update quota
    await AsyncStorage.setItem(fullKey, serialized);
    await this.updateUsedBytes(valueSize - existingSize);
  }
  
  async remove(key: string): Promise<void> {
    const fullKey = this.getFullKey(key);
    try {
      const existingValue = await AsyncStorage.getItem(fullKey);
      const existingSize = existingValue ? existingValue.length : 0;
      await AsyncStorage.removeItem(fullKey);
      if (existingSize > 0) {
        await this.updateUsedBytes(-existingSize);
      }
    } catch (error) {
      console.warn(`PractaStorage: Failed to remove key "${key}"`, error);
    }
  }
  
  async clear(): Promise<void> {
    try {
      const allKeys = await AsyncStorage.getAllKeys();
      const practaKeys = allKeys.filter(k => k.startsWith(this.prefix));
      if (practaKeys.length > 0) {
        await AsyncStorage.multiRemove(practaKeys);
      }
    } catch (error) {
      console.warn("PractaStorage: Failed to clear storage", error);
    }
  }
}
```

### FlowScreen Integration

In `FlowScreen.tsx`, create and inject the storage instance:

```typescript
import { PractaStorageManager } from "@/lib/practa-storage";
import { useDeviceId } from "@/hooks/useDeviceId"; // or from context

// Inside FlowScreen component:
const deviceId = useDeviceId(); // or userId if signed in

const storage = useMemo(() => {
  // Use canonical slug - for community practa, get from registry
  const slug = getCanonicalSlug(practa?.type);
  const userId = user?.id || `anon-${deviceId}`;
  return new PractaStorageManager(userId, slug);
}, [practa?.type, user?.id, deviceId]);

// Include in context passed to practa
const context: PractaContext = {
  practa,
  previous: previousOutput,
  storage,
};
```

### Type Updates

In `client/types/flow.ts`:

```typescript
export interface PractaStorage {
  get<T = unknown>(key: string): Promise<T | null>;
  set<T = unknown>(key: string, value: T): Promise<void>;
  remove(key: string): Promise<void>;
  clear(): Promise<void>;
}

export interface PractaContext {
  practa: PractaDefinition;
  previous?: PractaOutput;
  storage: PractaStorage;
}
```

## Safety Considerations

### Guardrails

| Guardrail | Limit | Enforcement |
|-----------|-------|-------------|
| Per-value size | 10KB | Reject on `set()` |
| Total per-practa quota | 100KB | Tracked via quota key, reject on `set()` |
| JSON serialization | Required | `JSON.stringify()` validation |
| Safe parsing | Corrupted → null | Try/catch on `get()` |
| Namespace isolation | User + Slug | Prefix-based |

### What Community Practa Cannot Do

- Access another practa's stored data
- Access another user's data
- Access app-level storage (meditation sessions, user preferences, etc.)
- Store non-serializable data (functions, class instances)
- Exceed storage quotas
- Crash the host by storing corrupted data

### Failure Scenarios

| Scenario | Behavior |
|----------|----------|
| `get()` with corrupted data | Returns `null`, logs warning |
| `set()` exceeds value limit | Throws error, practa should catch |
| `set()` exceeds quota | Throws error, practa should catch |
| AsyncStorage unavailable | Methods reject, practa should catch |
| User logout | Data remains (keyed by userId), inaccessible to new user |
| App uninstall | All data cleared by OS |

## Data Lifecycle

### When Data Persists

- App restart
- Device restart
- User logout (data remains, tied to user ID)

### When Data Is Cleared

- App uninstall
- User explicitly clears app data in device settings
- Practa calls `storage.clear()`
- (Future) Account deletion API clears user's namespace

### Logout Behavior

When a user logs out:
1. Their data remains in storage (keyed by their userId)
2. The new user (or anonymous session) gets a fresh namespace
3. If the original user logs back in, their data is still there

## Future Considerations

### Cloud Sync (Phase 2)

The storage interface could be extended to support optional cloud sync:

```typescript
interface PractaStorage {
  // ... existing methods
  sync(): Promise<void>;  // Push local changes to server
  isSynced(): boolean;    // Check sync status
}
```

### Migration Strategy

If a practa's slug changes (e.g., `sudoku` → `daily-sudoku`):
1. Old data becomes orphaned under the old slug
2. New installations use new slug
3. (Optional) Migration script can be provided to move data

## Files to Create/Modify

1. **Create** `client/lib/practa-storage.ts` - PractaStorageManager class
2. **Modify** `client/types/flow.ts` - Add PractaStorage interface, update PractaContext
3. **Modify** `client/screens/FlowScreen.tsx` - Create and inject storage instance
4. **Modify** built-in practa to use storage for preferences (optional)

## Testing Plan

1. Create a test practa that saves/loads a simple preference
2. Verify data persists after app restart
3. Verify practa A cannot access practa B's data
4. Verify user A cannot access user B's data
5. Verify size limits are enforced (per-value and quota)
6. Verify corrupted data returns null instead of crashing
7. Verify `clear()` only removes that practa's data for that user
8. Test logout/login cycle preserves data per user
