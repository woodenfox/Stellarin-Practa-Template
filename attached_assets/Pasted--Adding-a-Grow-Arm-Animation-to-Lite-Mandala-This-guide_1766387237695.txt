# Adding a Grow Arm Animation to Lite Mandala

This guide walks through adding an animated "grow arm" feature to the Lite Mandala component. When triggered, soothing energy rings flow inward from outside the spiral while a new arm smoothly appears.

## Step 1: Add the Animation Type

First, define the animation state type:

```typescript
interface GrowthAnimation {
  active: boolean;
  startTime: number;
  fromArms: number;
  toArms: number;
}
```

## Step 2: Add Props to Your Canvas Component

Extend your canvas props to accept the animation state:

```typescript
interface LiteMandalaCanvasProps {
  parameters: MandalaParameters;
  width?: number;
  height?: number;
  animate?: boolean;
  growthAnimation?: GrowthAnimation;  // Add this
}
```

Update the function signature:

```typescript
function LiteMandalaCanvas({ 
  parameters, 
  width = 800, 
  height = 800, 
  animate = true,
  growthAnimation  // Add this
}: LiteMandalaCanvasProps) {
```

## Step 3: Add Easing Functions

Add these inside your component for smooth animation curves:

```typescript
const easeOutCubic = (t: number) => 1 - Math.pow(1 - t, 3);
const easeInOutQuart = (t: number) => 
  t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2;
```

## Step 4: Calculate Animation Progress

At the start of your `drawMandala` function, before any drawing, add logic to calculate the current animation state:

```typescript
const drawMandala = (
  ctx: CanvasRenderingContext2D, 
  time: number, 
  w: number, 
  h: number, 
  darkMode: boolean,
  growth?: GrowthAnimation  // Add this parameter
) => {
  const { arms: baseArms = 6, /* ...other params */ } = parameters;

  // Animation state
  let arms = baseArms;
  let glowIntensity = 0;
  
  if (growth?.active) {
    const elapsed = time - growth.startTime;
    const duration = 3500;
    const rawProgress = Math.min(elapsed / duration, 1);
    
    // Smooth arm count interpolation
    const growthProgress = easeInOutQuart(rawProgress);
    arms = growth.fromArms + (growth.toArms - growth.fromArms) * growthProgress;
    
    // Ring intensity: fade in -> hold -> fade out
    if (rawProgress < 0.3) {
      glowIntensity = easeOutCubic(rawProgress / 0.3);
    } else if (rawProgress < 0.7) {
      glowIntensity = 1;
    } else {
      glowIntensity = 1 - easeOutCubic((rawProgress - 0.7) / 0.3);
    }
  }

  // Continue with existing drawing code...
  // Use `arms` (not baseArms) for the spiral arm count
```

## Step 5: Draw the Energy Rings

After drawing the background but before drawing the spiral, add the ring effect:

```typescript
// Draw background first...
ctx.fillRect(0, 0, w, h);

// Energy rings (only visible during animation)
if (glowIntensity > 0) {
  const ringCount = 3;
  const animSpeed = time * 0.0015;
  
  for (let i = 0; i < ringCount; i++) {
    const ringPhase = (i / ringCount + animSpeed) % 1;
    const ringProgress = 1 - ringPhase;
    
    // Position rings outside the spiral
    const outerStart = maxRadius * 1.3;
    const outerEnd = maxRadius * 0.95;
    const ringRadius = outerEnd + (outerStart - outerEnd) * ringProgress;
    
    // Smooth opacity
    const ringAlpha = Math.sin(ringPhase * Math.PI) * glowIntensity * 0.35;
    
    if (ringAlpha > 0.01) {
      ctx.strokeStyle = `hsla(199, 70%, 60%, ${ringAlpha})`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx, cy, ringRadius, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
}

// Then draw the spiral...
```

## Step 6: Update the Render Loop

Modify your useEffect to pass the animation and keep rendering during growth:

```typescript
useEffect(() => {
  const canvas = canvasRef.current;
  if (!canvas) return;

  const ctx = canvas.getContext("2d");
  if (!ctx) return;

  const render = (timestamp: number) => {
    // Keep time updating during animation
    if (animate || growthAnimation?.active) {
      timeRef.current = timestamp;
    }
    
    // Pass growth animation to draw function
    drawMandala(ctx, timeRef.current, width, height, isDarkRef.current, growthAnimation);
    
    // Continue animation loop during growth
    if (animate || growthAnimation?.active) {
      animationRef.current = requestAnimationFrame(render);
    }
  };

  render(timeRef.current);

  return () => {
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
    }
  };
}, [parameters, width, height, animate, isDark, growthAnimation]);  // Add growthAnimation
```

## Step 7: Add State to Your Page Component

In the parent component that renders the canvas:

```typescript
const [armCount, setArmCount] = useState(6);
const [growthAnimation, setGrowthAnimation] = useState<GrowthAnimation | undefined>();
const [isGrowing, setIsGrowing] = useState(false);

const handleGrowArm = () => {
  if (isGrowing || armCount >= 24) return;
  
  setIsGrowing(true);
  const newArmCount = armCount + 1;
  
  // Start the animation
  setGrowthAnimation({
    active: true,
    startTime: performance.now(),
    fromArms: armCount,
    toArms: newArmCount
  });
  
  // End animation after 3.5 seconds
  setTimeout(() => {
    setArmCount(newArmCount);
    setGrowthAnimation(undefined);
    setIsGrowing(false);
  }, 3500);
};

// Update params to use current arm count
const currentParams = {
  ...DEFAULT_PARAMS,
  arms: armCount
};
```

## Step 8: Add the Button

```tsx
<LiteMandalaCanvas 
  parameters={currentParams}
  width={350}
  height={350}
  animate={true}
  growthAnimation={growthAnimation}
/>

<Button
  onClick={handleGrowArm}
  disabled={isGrowing || armCount >= 24}
>
  {isGrowing ? "Growing..." : `Grow Arm (${armCount} arms)`}
</Button>
```

## Customization

| Setting | Location | Effect |
|---------|----------|--------|
| Animation duration | `duration = 3500` and `setTimeout(..., 3500)` | Total animation time in ms |
| Ring count | `ringCount = 3` | Number of flowing rings |
| Ring speed | `time * 0.0015` | Lower = slower, more soothing |
| Ring color | `hsla(199, 70%, 60%...)` | Hue, saturation, lightness |
| Ring opacity | `* 0.35` | Max ring visibility |
| Ring range | `outerStart` / `outerEnd` | Where rings appear and travel to |
| Max arms | `armCount >= 24` | Upper limit for arm growth |
